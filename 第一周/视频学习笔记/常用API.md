# 常用API

## 1.Math类

### 1.Math类中的常用方法

![屏幕截图 2024-07-10 141019](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 141019.png)

![屏幕截图 2024-07-10 142133](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 142133.png)

**更多详情请查询API文档**

### 2.Math类的两个常量

1.pi：圆周率 

2.E：无理数e

### 3.注意点

1.abs在int边界中会存在bug，要获得精确值要用absExact，超值时会报错。

## 2.System类

### 1.System类中的常用方法

![屏幕截图 2024-07-10 142658](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 142658.png)

第二个方法获取时间戳

## 3.Runtime类

### 1.Runtime类中的常用方法

![屏幕截图 2024-07-10 143358](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 143358.png)

### 2.注意点：

非静态方法哟啊创建对象，Runtime设计为单例模式。	

![屏幕截图 2024-07-10 144003](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 144003.png)

## 4.Object类

### 1.Object类中的常用方法

![屏幕截图 2024-07-10 145148](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 145148.png)

#### 详细讲clone：

#### **方法的使用：**

![屏幕截图 2024-07-10 145904](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 145904.png)

图一种重写了clone

![屏幕截图 2024-07-10 150002](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 150002.png)

主代码

#### **两种克隆策略：**

两种clone方式在于clone重写的不同

##### 1.浅克隆：

目的是将对象地址值进行克隆。（Object自带的clone）

clone方法的代码如下：

![屏幕截图 2024-07-10 150954](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 150954.png)

内存图为：

![屏幕截图 2024-07-10 151115](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 151115.png)

将基本类型数据进行赋值，将引用数据类型的地址值进行赋值。

##### 2.深克隆

目的是将对象的值进行克隆。

代码方法：

1.引入Gson放到lib中

然后主程序代码为：

![屏幕截图 2024-07-10 152354](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 152354.png)

Gson的原理就是将对象的属性值转为字符串，然后通过Gson自己的方法将字符串数据赋值到新对象。

内存图：

![image-20240710151513683](C:\Users\30864\AppData\Roaming\Typora\typora-user-images\image-20240710151513683.png)

将基本数据类型进行赋值，数组则重开一块内存然后赋值。上图中字符串地址一致是因为串池中字符串的复用，本身目的只是数值的赋值。

### 2.注意点：

1.当这些方法不够满足需求，重写。

2.toString返回形式为属性值：包名@地址值。这个是println的底层代码

3.equals比较时先看传入对象，传入对象一致，直接返回true，否则先看是否是字符串，是则比较属性，否则返回false

![屏幕截图 2024-07-10 145023](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 145023.png)

## 5.Objects类（Object的工具类）

### 1.Objects类中常用方法

![屏幕截图 2024-07-10 153205](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 153205.png)

### 2.注意点

1.Objects.equals底层:

![屏幕截图 2024-07-10 153500](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 153500.png)

## 6.BigInteger（多位的整数）

### 1.构造方法

![屏幕截图 2024-07-10 154323](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 154323.png)

### 2.成员方法

![屏幕截图 2024-07-10 155113](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 155113.png)

### 3.底层

将传入的字符分成两个部分，第一个是符号，第二个是数。在数的部分将其转换成补码，从右到左每32位分为一组转成十进制存储在数组中进行存储。

### 4.注意点：

1.构造方法第三个方法中：第一个参数是数字，第二个参数是该数字的进制

2.构造方法第四个方法中：范围在long的范围内，-16~16是已经准备好的对象

3.当BigInteger进行了计算，则会创建一个新对象，需要自己去接收

4.成员方法中的equals是比较数值。

5.成员方法中最后一个方法可以改int为long就可以long类型整数。

## 7.BigDecima(多位的小数)

### 1.构造方法

```java
//1.括号内可以传字符串或小数，它的底层是将传入的东西变为字符串。由于输入小数的时候转换不精确，所以这里建议传入字符串
BigDecima bd=new BigDecima();
//2.静态方法
BigDecima.valueOf();//参数是int值时，在底层将传入的数转换为double，其中[0,10]已创建，传入时直接引用。传入double时则不管范围直接new
```

### 2.成员方法

![屏幕截图 2024-07-10 161409](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 161409.png)

舍入模式：在RoundingMode类中，是静态成员，直接引用，如四舍五入RoundingMode.HALF_UP。

### 3.底层

将数据转化为字符串，每个以ASCII码存储。

## 8.正则表达式

正则表达式可以校验字符串是否满足一定的规则，并用来校验数据格式的合法性。

### 1.正则表达式

![屏幕截图 2024-07-10 163537](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 163537.png)

![屏幕截图 2024-07-10 171502](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 171502.png)

![屏幕截图 2024-07-10 171513](C:\Users\30864\Pictures\Screenshots\屏幕截图 2024-07-10 171513.png)

### 2.使用方法(在帮助文档的pattern中)

string1.match();括号里输入正则表达式的字符串形式

字符类用法示例

```java

"a".matches("[abc]")//结果是true
"ab".matches("[abc]")//结果为false，该表达式只判断了a在第一个范围
"ab".matches("[abc][abc]")//结果为true，该表达式判断了两个，a从第一个判断，b从第二个判断
"&".matches("[a-b&[def]")//true
"&".matches("[a-b&&[def]")//false
方括号表示范围
```

预定类用法示例

```java
"a".matches("..")//false.因为后面有两个而你只有一个
"1".match("\\d")//true.
"0\\d{2,3}-？"//表示第一位是1，后面是任意数字符，可出现2到3次，—出现0到一次
```

